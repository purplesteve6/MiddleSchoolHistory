<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Middle East Map Challenge | Middle School History</title>

  <!-- Global site styles -->
  <link rel="stylesheet" href="/styles.css" />

  <!-- Page-specific styles -->
  <link rel="stylesheet" href="/games/map-challenges/middle-east/middle-east.css" />

  <!-- Small additions (flag + cursor tooltip). Kept here so you donâ€™t have to touch the CSS file. -->
  <style>
    /* Make the prompt able to hold a flag nicely */
    .hud__prompt{
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    .hud__flag{
  width: 48px;
  height: auto;          /* preserves your 163x100 ratio */
  object-fit: contain;
  border: none;
  border-radius: 0;
  box-shadow: none;
  transform: none;
}


    /* Tooltip that follows the cursor during play */
    .cursor-tip{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      display: none;

      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.70);
      border: 1px solid rgba(255,255,255,0.16);
      color: rgba(255,255,255,0.95);

      font-family: "Tommy Soft", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px;
      line-height: 1;
      white-space: nowrap;

      box-shadow: 0 14px 34px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
    }
    body.is-playing .cursor-tip.is-on{
      display: block;
    }
  </style>
</head>

<body class="map-challenge-page">

  <!-- MAIN SITE HEADER (injected) -->
  <div id="siteHeader" data-include="/partials/main-header.html"></div>

  <!-- Full-width band under header -->
  <section class="challenge-band challenge-band--image"
           style="background-image: url('/assets/images/banners/map-challenges-banner.jpg');"
           aria-label="Middle East Map Challenge banner">
    <div class="challenge-band__bottom">
      <div class="challenge-band__inner">
        <h1 class="challenge-band__title">MIDDLE EAST MAP CHALLENGE</h1>
      </div>
    </div>
  </section>

  <main class="challenge-main" aria-label="Middle East map challenge">
    <section class="map-stage" aria-label="Map stage">

      <!-- HUD -->
      <div class="hud" aria-label="Game HUD">
        <div class="hud__prompt">
          Click:
          <span id="targetName">â€”</span>
          <img
            id="targetFlag"
            class="hud__flag"
            src=""
            alt=""
            width="34"
            height="22"
            style="display:none;"
          />
        </div>

        <div class="hud__right">
          <div class="hud__timer" id="timer">00:00.000</div>
          <button class="hud__reset" id="resetBtn" type="button">Reset</button>
        </div>
      </div>

      <!-- SVG gets injected here -->
      <div class="map-box" id="mapBox" aria-label="Middle East map"></div>

      <!-- Cursor-follow tooltip -->
      <div class="cursor-tip" id="cursorTip" aria-hidden="true"></div>

      <!-- Dark overlay shown on load -->
<div class="start-overlay" id="startOverlay" aria-label="Start overlay">
  <div class="start-overlay__card">
    <div class="overlay__kicker">MAP CHALLENGE</div>
    <div class="overlay__title">MIDDLE EAST</div>

    <div class="overlay__body">
      How fast can you identify the countries of the Middle East?
    </div>

    <div class="overlay__actions">
      <button class="begin-btn" id="beginBtn" type="button">Begin</button>
    </div>

    <img class="overlay__logo"
         src="/assets/images/logo/MSHistory_Logo_Small.png"
         alt="Middle School History logo" />
  </div>
</div>

    </section>
  </main>

  <!-- FOOTER (injected) -->
  <div id="siteFooter" data-include="/partials/footer.html"></div>

  <!-- Inject header/footer -->
  <script src="/include.js"></script>

  <!-- Game logic -->
  <script>
  (function () {
    const SVG_PATH = "/games/map-challenges/middle-east/middle_east_clickable.svg";
    const FLAGS_BASE = "/games/map-challenges/middle-east/flags/";

    const COUNTRIES = [
      "bahrain","cyprus","egypt","iran","iraq","israel","jordan","kuwait",
      "lebanon","oman","qatar","saudi_arabia","syria","turkey","uae","yemen"
    ];

    // Not clickable + should NOT count as wrong
    const IGNORE = new Set(["water","borders","context_land"]);

    // Alias clicks on palestine/gaza/internal borders -> israel
    // israel_internal_borders should behave like clicking Israel for correctness,
    // but it should NOT be colored itself (it's a border layer only).
    const ALIAS = {
      palestine: "israel",
      gaza: "israel",
      israel_internal_borders: "israel",
      israel: "israel"
    };

    // Treat these SVG layers exactly like Israel for coloring/blinking
    // (DO NOT include israel_internal_borders here â€” it's a border layer only)
    const GROUPS = {
      israel: ["israel", "gaza", "palestine"]
    };

    // Clear classes from these extra IDs too (not in COUNTRIES list)
    const EXTRA_IDS = ["gaza", "palestine", "israel_internal_borders"];

    // Display name overrides
    const DISPLAY_NAMES = {
      uae: "United Arab Emirates (UAE)"
    };

    const LOGO_SRC = "/assets/images/logo/MSHistory_Logo_Small.png";
    const GAME_KICKER = "MAP CHALLENGE";
    const GAME_TITLE = "MIDDLE EAST";

    const mapBox = document.getElementById("mapBox");
    const overlay = document.getElementById("startOverlay");
    const beginBtn = document.getElementById("beginBtn");
    const resetBtn = document.getElementById("resetBtn");
    const targetNameEl = document.getElementById("targetName");
    const targetFlagEl = document.getElementById("targetFlag");
    const timerEl = document.getElementById("timer");
    const cursorTipEl = document.getElementById("cursorTip");

    let svgRoot = null;

    // Game state
    let remaining = [];
    let currentTarget = null;
    let tries = 0; // 0 = first attempt, 1 = second attempt
    let totalPoints = 0;

    // countries already completed (green/yellow/red) should ignore clicks
    let locked = new Set();

    let timerStart = 0;
    let timerInt = null;

    // Track pointer-down temporary red
    let tempWrongEl = null;

let lastMouseX = 0;
let lastMouseY = 0;

    function shuffle(arr){
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function fmtTime(ms){
      const minutes = Math.floor(ms / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      const millis  = ms % 1000;
      return `${String(minutes).padStart(2,"0")}:${String(seconds).padStart(2,"0")}.${String(millis).padStart(3,"0")}`;
    }

    function startTimer(){
      stopTimer();
      timerStart = Date.now();
      timerEl.textContent = "00:00.000";
      timerInt = setInterval(() => {
        timerEl.textContent = fmtTime(Date.now() - timerStart);
      }, 31);
    }

    function stopTimer(){
      if (timerInt) clearInterval(timerInt);
      timerInt = null;
    }

    function displayNameFor(id){
  const base = DISPLAY_NAMES[id] ?? id.replaceAll("_"," ");

  // Capitalize each word nicely
  return base.replace(/\b\w/g, char => char.toUpperCase());
}


    function flagSrcFor(id){
      return `${FLAGS_BASE}${id}.jpg`;
    }

    function setFlagForCurrent(){
      if (!targetFlagEl) return;

      if (!currentTarget){
        targetFlagEl.style.display = "none";
        targetFlagEl.src = "";
        targetFlagEl.alt = "";
        return;
      }

      const src = flagSrcFor(currentTarget);
      targetFlagEl.src = src;
      targetFlagEl.alt = `${displayNameFor(currentTarget)} flag`;
      targetFlagEl.style.display = "inline-block";

      // If an image is missing, hide gracefully
      targetFlagEl.onerror = () => {
        targetFlagEl.style.display = "none";
      };
    }

    function setPrompt(){
      if (!currentTarget){
        targetNameEl.textContent = "Done!";
        setFlagForCurrent();
        return;
      }

      targetNameEl.textContent = displayNameFor(currentTarget);
      setFlagForCurrent();
    }

    function getElById(id){
      if (!svgRoot) return null;
      return svgRoot.querySelector(`#${CSS.escape(id)}`);
    }

    function forEachGroupEl(countryId, fn){
      const group = GROUPS[countryId];
      if (group && group.length){
        group.forEach(id => {
          const el = getElById(id);
          if (el) fn(el);
        });
        return;
      }
      const el = getElById(countryId);
      if (el) fn(el);
    }

    // If user clicked israel_internal_borders, correctness should count as Israel,
    // but colors should apply to the Israel group, not the border layer.
    function getVisualElForHit(hit){
      if (!hit) return null;

      // Border layer: never color it; "visual" should be the Israel region instead
      if (hit.raw === "israel_internal_borders"){
        return getElById("israel");
      }

      // Gaza/Palestine should color themselves (they are part of Israel group)
      return hit.el;
    }

    function clearAllCountryClasses(){
      if (!svgRoot) return;

      const allIds = COUNTRIES.concat(EXTRA_IDS);
      for (const id of allIds){
        const el = getElById(id);
        if (el) el.classList.remove("correct1","correct2","wrongFinal","blink","tempWrong");
      }
    }

    function pickNext(){
  currentTarget = remaining.shift() || null;
  tries = 0;
  setPrompt();

  if (!currentTarget){
    endGame();
    return;
  }

  // ðŸ”¥ Immediately update tooltip if visible
  if (canShowCursorTip()){
    showCursorTip(lastMouseX, lastMouseY);
  }
}


    function showEndOverlay({ title, time, scorePercent, stamp }){
      const old = document.getElementById("endOverlay");
      if (old) old.remove();

      const wrap = document.createElement("div");
      wrap.id = "endOverlay";
      wrap.className = "start-overlay";
      wrap.innerHTML = `
        <div class="start-overlay__card" role="dialog" aria-modal="true" aria-label="Results">
          <div class="overlay__kicker">${GAME_KICKER}</div>
          <div class="overlay__title">${title}</div>

          <div class="results-metrics">
            <div class="results-metric">
              <div class="results-label">SCORE</div>
              <div class="results-value">${scorePercent}</div>
            </div>

            <div class="results-metric">
              <div class="results-label">TIME</div>
              <div class="results-value">${time}</div>
            </div>
          </div>

          <div class="results-completed">
            Completed: ${stamp}
          </div>

          <div class="overlay__actions">
            <button class="begin-btn" id="playAgainBtn" type="button">Play Again</button>
          </div>

          <img class="overlay__logo"
               src="${LOGO_SRC}"
               alt="Middle School History logo" />
        </div>
      `;

      const stage = mapBox.closest(".map-stage");
      stage.appendChild(wrap);

      wrap.querySelector("#playAgainBtn").addEventListener("click", () => {
        wrap.remove();
        resetGame(true);
      });
    }

    function endGame(){
      stopTimer();
      const elapsed = Date.now() - timerStart;

      // Average points out of 100 (same as percent)
      const avg = totalPoints / COUNTRIES.length;
      const avgPercent = `${avg.toFixed(1)}%`;

      showEndOverlay({
        title: GAME_TITLE,
        time: fmtTime(elapsed),
        scorePercent: avgPercent,
        stamp: new Date().toLocaleString()
      });

      // Hide cursor tip when game ends
      hideCursorTip();
    }

    function resetGame(startImmediately=false){
      stopTimer();
      document.body.classList.remove("is-playing");

      remaining = [];
      currentTarget = null;
      tries = 0;
      totalPoints = 0;
      locked = new Set();

      clearAllCountryClasses();

      targetNameEl.textContent = "â€”";
      timerEl.textContent = "00:00.000";
      if (targetFlagEl){
        targetFlagEl.style.display = "none";
        targetFlagEl.src = "";
        targetFlagEl.alt = "";
      }

      hideCursorTip();

      if (overlay && !startImmediately) overlay.classList.remove("is-hidden");

      if (startImmediately) {
        if (overlay) overlay.classList.add("is-hidden");
        document.body.classList.add("is-playing");
        remaining = shuffle(COUNTRIES);
        pickNext();
        startTimer();
      }
    }

    function normalizeClickedId(e){
      const targetEl = (e.target && e.target.closest)
        ? e.target.closest(
            "#bahrain,#cyprus,#egypt,#iran,#iraq,#israel,#jordan,#kuwait,#lebanon,#oman,#qatar,#saudi_arabia,#syria,#turkey,#uae,#yemen,#palestine,#gaza,#israel_internal_borders,#water,#borders,#context_land"
          )
        : null;

      if (!targetEl) return null;

      const raw = String(targetEl.id).toLowerCase();
      if (IGNORE.has(raw)) return null;

      const normalized = ALIAS[raw] ?? raw;
      if (!COUNTRIES.includes(normalized)) return null;

      return { raw, normalized, el: targetEl };
    }

    function flashCorrectThenRed(){
      // On second wrong: flash the CORRECT country then lock red
      forEachGroupEl(currentTarget, (el) => el.classList.remove("correct1","correct2"));
      forEachGroupEl(currentTarget, (el) => el.classList.add("blink"));

      setTimeout(() => {
        forEachGroupEl(currentTarget, (el) => el.classList.remove("blink"));
        forEachGroupEl(currentTarget, (el) => el.classList.add("wrongFinal"));
        locked.add(currentTarget);
        pickNext();
      }, 520);
    }

    async function loadSvg(){
      const res = await fetch(SVG_PATH, { cache: "no-store" });
      if (!res.ok) throw new Error(`SVG fetch failed: ${res.status}`);
      const svgText = await res.text();

      mapBox.innerHTML = svgText;
      svgRoot = mapBox.querySelector("svg");

      if (svgRoot){
        svgRoot.setAttribute("preserveAspectRatio", "xMidYMid meet");
        svgRoot.removeAttribute("width");
        svgRoot.removeAttribute("height");
        svgRoot.style.width = "100%";
        svgRoot.style.height = "100%";
        svgRoot.style.display = "block";

        // Make the container match the SVGâ€™s actual viewBox aspect ratio
        const vb = svgRoot.getAttribute("viewBox");
        if (vb) {
          const parts = vb.trim().split(/\s+/).map(Number);
          if (parts.length === 4 && parts.every(n => Number.isFinite(n))) {
            const w = parts[2], h = parts[3];
            if (w > 0 && h > 0) {
              mapBox.style.setProperty("--map-ar", `${w} / ${h}`);
            }
          }
        }
      }
    }

    /* ==========================
       Cursor Tooltip (NEW)
       ========================== */
    function canShowCursorTip(){
      // Show only during play, when no overlays are up, and we have a target.
      if (!document.body.classList.contains("is-playing")) return false;
      if (!currentTarget) return false;
      if (overlay && !overlay.classList.contains("is-hidden")) return false;
      if (document.getElementById("endOverlay")) return false;
      return true;
    }

    function showCursorTip(clientX, clientY){
      if (!cursorTipEl) return;
      if (!canShowCursorTip()) return;

      cursorTipEl.textContent = displayNameFor(currentTarget);
      cursorTipEl.classList.add("is-on");

      const offsetX = 14;
      const offsetY = 18;

      // Keep inside viewport a bit
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      cursorTipEl.style.left = "0px";
      cursorTipEl.style.top = "0px";

      // after text is set, measure
      const rect = cursorTipEl.getBoundingClientRect();

      let x = clientX + offsetX;
      let y = clientY + offsetY;

      if (x + rect.width + 10 > vw) x = clientX - rect.width - 10;
      if (y + rect.height + 10 > vh) y = clientY - rect.height - 10;

      cursorTipEl.style.left = `${x}px`;
      cursorTipEl.style.top = `${y}px`;
    }

    function hideCursorTip(){
      if (!cursorTipEl) return;
      cursorTipEl.classList.remove("is-on");
      cursorTipEl.style.left = "0px";
      cursorTipEl.style.top = "0px";
    }

   mapBox.addEventListener("pointermove", (e) => {
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;

  if (!canShowCursorTip()){
    hideCursorTip();
    return;
  }
  showCursorTip(lastMouseX, lastMouseY);
});


    mapBox.addEventListener("pointerleave", () => hideCursorTip());
    window.addEventListener("scroll", () => {
      // Keep it tidy while scrolling
      if (!canShowCursorTip()) hideCursorTip();
    }, { passive: true });

    /* ==========================
       Click Handling
       ========================== */
    mapBox.addEventListener("pointerdown", (e) => {
      const hit = normalizeClickedId(e);
      if (!hit) return;

      // If that country already completed, ignore (no penalty)
      if (locked.has(hit.normalized)) return;

      // Only accept clicks during play
      if (!document.body.classList.contains("is-playing")) return;

      // Correct?
      if (hit.normalized === currentTarget){
        if (tries === 0){
          totalPoints += 100;
          forEachGroupEl(currentTarget, (el) => el.classList.add("correct1"));
          locked.add(currentTarget);
          pickNext();
        } else {
          totalPoints += 50;
          forEachGroupEl(currentTarget, (el) => el.classList.add("correct2"));
          locked.add(currentTarget);
          pickNext();
        }
        return;
      }

      // Wrong click
      if (tries === 0){
        // First wrong: show clicked region red only while held down
        tempWrongEl = getVisualElForHit(hit);
        if (tempWrongEl){
          tempWrongEl.classList.add("tempWrong");
          tries = 1;
          try { tempWrongEl.setPointerCapture(e.pointerId); } catch(_) {}
        }
      } else {
        // Second wrong: 0 points; flash the CORRECT country then lock red
        flashCorrectThenRed();
        tries = 0;
      }
    });

    mapBox.addEventListener("pointerup", () => {
      if (tempWrongEl){
        tempWrongEl.classList.remove("tempWrong");
        tempWrongEl = null;
      }
    });

    mapBox.addEventListener("pointercancel", () => {
      if (tempWrongEl){
        tempWrongEl.classList.remove("tempWrong");
        tempWrongEl = null;
      }
    });

    // Begin
    if (beginBtn){
      beginBtn.addEventListener("click", () => {
        const endOverlay = document.getElementById("endOverlay");
        if (endOverlay) endOverlay.remove();

        if (overlay) overlay.classList.add("is-hidden");
        document.body.classList.add("is-playing");

        clearAllCountryClasses();
        totalPoints = 0;

        locked = new Set();
        remaining = shuffle(COUNTRIES);
        pickNext();
        startTimer();
      });
    }

    // Reset
    if (resetBtn){
      resetBtn.addEventListener("click", () => resetGame(false));
    }

    // Spacebar activates Begin / Play Again when an overlay is visible.
    document.addEventListener("keydown", (e) => {
      if (e.code !== "Space" && e.key !== " ") return;

      // If start overlay is up, Space should click Begin
      if (overlay && !overlay.classList.contains("is-hidden")){
        e.preventDefault();
        beginBtn?.click();
        return;
      }

      // If end overlay is up, Space should click Play Again
      const endOverlay = document.getElementById("endOverlay");
      if (endOverlay){
        const playAgainBtn = endOverlay.querySelector("#playAgainBtn");
        if (playAgainBtn){
          e.preventDefault();
          playAgainBtn.click();
        }
      }
    });

    // Boot
    loadSvg().catch(err => {
      console.error(err);
      mapBox.innerHTML = "<div style='padding:16px;color:#fff'>Could not load map SVG.</div>";
    });
  })();
  </script>
</body>
</html>
